<!doctype linuxdoc public "-//LinuxDoc//DTD LinuxDoc 96//EN">

<linuxdoc>

<article>

<titlepag>
<title> The DOSEMU Alterer Novices Guide </title>
<author> <name> Alistair MacDonald, &lt;alistair@slitesys.demon.co.uk&gt; </name> </author>
<date> version dosemu-1.3.3 </date>
<abstract>
This Document is the DOSEMU Alterer Novices Guide. It is known as the DANG.
</abstract>
</titlepag>

<toc>

<sect><heading>Introduction</heading>

<p>
This document is the preliminary draft of a manual to help
people understand the inner workings of dosemu.  It is the goal of
this document to create new dosemu hackers.  This concept was inspired
by the linux kernel hackers guide.

This Guide was concieved and originally written by "Corey Sweeney"
&lt;corey@interaccess.com&gt;. It has been completely revised. It is now
generated automatically directly from the source code. Special thanks to
"James B. MacLean" &lt;macleajb@ednet.ns.ca&gt; for supplying the original
information. (It was mostly ripped out of a mail message.) "Jochen Hein"
has made many useful comments &amp; suggestions.

At the end if this document is a section detailing how this guide is put 
together. This may help you when trying to locate the relevant pieces of
code. If you add new code, it would be useful if the relevant markers 
are added where appropriate.

This file is a collective effort. If you don't like one of the
explanations, or want to add anything, please send me something!



</p></sect>

<sect><heading>The Main group of Modules</heading>
<p>
These files are used to start DOSEMU as well as hold globally called
functions and global vars.
</p>

<sect1><heading>Functions in dos.c</heading>

<p>These are the functions defined in dos.c.</p>

<sect2><heading>dosemu</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  argc - Count of argumnents.</item>
<item>  argc - Actual arguments.</item>
</itemize>
  Function created by entry point into libdosemu. Called to
  jump into the emulate function of DOSEMU.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in emu.c</heading>

<p>These are the functions defined in emu.c.</p>

<sect2><heading>jmp_emulate</heading>


<p>
 
 call the emulate function by way of the dll headers. Always make sure
 that this line is the first of emu.c and link emu.o as the first object
 file to the lib
 
 
</p>
</sect2>
<sect2><heading>emulate</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  argc - Argument count. </item>
<item>  argv - Arguments.</item>
</itemize>
 Emulate gets called from dos.c. It initializes DOSEMU to
 prepare it for running in vm86 mode. This involves catching signals,
 preparing memory, calling all the initialization functions for the I/O
 subsystems (video/serial/etc...), getting the boot sector instructions
 and calling vm86().
 
 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in emu.c</heading>

<p>
 DOSEMU must not work within the 1 meg DOS limit, so
 start of code is loaded at a higher address, at some time this could
 conflict with other shared libs. If DOSEMU is compiled statically
 (without shared libs), and org instruction is used to provide the jump
 above 1 meg. 
 
</p>
</sect1>

<sect1><heading>Remarks in include/emu.h</heading>

<p>
 The `vm86_struct` is used to pass all the necessary status/registers to
   DOSEMU when running in vm86 mode.
 
</p><p>-----</p>

<p> DOSEMU keeps system wide configuration status in a structure
 called config.
 
</p><p>-----</p>

<p> The var `fatalerr` can be given a true value at any time to have DOSEMU
 exit on the next return from vm86 mode.
 
</p><p>-----</p>

<p> The var 'running_DosC' is set by the DosC kernel and is used to handle
 some things differently, e.g. the redirector.
 It interfaces via INTe6,0xDC (DOS_HELPER_DOSC), but only if running_DosC
 is !=0. At the very startup DosC issues a INTe6,0xdcDC to set running_DosC
 with the contents of BX (which is the internal DosC version).
 
</p>
</sect1>

</sect>

<sect><heading>The Init group of Modules</heading>
<p>
These files are used for initialization and runtime configuration of DOSEMU
</p>

<sect1><heading>Functions in base/init/init.c</heading>

<p>These are the functions defined in base/init/init.c.</p>

<sect2><heading>stdio_init</heading>


<p>
 
  Initialize stdio, open debugging output file if user specified one
 
 
</p>
</sect2>
<sect2><heading>time_setting_init</heading>


<p>
 
  Beats me
 
 
</p>
</sect2>
<sect2><heading>timer_interrupt_init</heading>


<p>
 
  Tells the OS to send us periodic timer messages
 
 
</p>
</sect2>
<sect2><heading>map_video_bios</heading>


<p>
 
  Map the video bios into main memory
 
 
</p>
</sect2>
<sect2><heading>map_custom_bios</heading>


<p>
 
  Setup the dosemu amazing custom BIOS, quietly overwriting anything
  was copied there before. Do not overwrite graphic fonts!
 
 
</p>
</sect2>
<sect2><heading>memory_init</heading>


<p>
 
  Set up all memory areas as would be present on a typical i86 during
 the boot phase.
 
 
</p>
</sect2>
<sect2><heading>device_init</heading>


<p>
 
  Calls all initialization routines for devices (keyboard, video, serial,
    disks, etc.)
 
 
</p>
</sect2>
<sect2><heading>low_mem_init</heading>


<p>
 
  Initializes the lower 1Meg via mmap &amp; sets up the HMA region
 
 
</p>
</sect2>
<sect2><heading>version_init</heading>


<p>
 
  Find version of OS running and set necessary global parms.
 
 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in base/init/config.c</heading>

<p>These are the functions defined in base/init/config.c.</p>

<sect2><heading>cpu_override</heading>


<p>
 
 Process user CPU override from the config file ('cpu xxx') or
 from the command line. Returns the selected CPU identifier or
 -1 on error. 'config.realcpu' should have already been defined.
 
 
</p>
</sect2>
<sect2><heading>register_config_scrub</heading>


<p>
 
 register a function Enforce consistency upon the `config` structure after
 all values have been set to remove silly option combinations
 
 
</p>
</sect2>
<sect2><heading>unregister_config_scrub</heading>


<p>
 
 Complement of register_config_scrub 
 This removes a scrub function.
 
 
</p>
</sect2>
<sect2><heading>config_scrub</heading>


<p>
 
 Enforce consistency upon the `config` structure after
 all values have been set to remove silly option combinations
 
 
</p>
</sect2>
<sect2><heading>config_init</heading>


<p>
 
 This is called to parse the command-line arguments and config
 files. 
 
 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in base/init/config.c</heading>

<p>
 For simpler support of X, DOSEMU can be started
 by a symbolic link called `xdos` which DOSEMU will use to switch
 into X-mode. 
</p>
</sect1>

</sect>

<sect><heading>The DPMI group of Modules</heading>
<p>
DPMI is Lutz's Baby. It's a really important part of the Emulator as far
as we are concerned, since it will allow us to run so many more programs
and, most importantly, bcc. This is the one thing that the WINE developers
want that we haven't been able to give them.

If you think you can help .... "Away you Go!" (Sorry to those non-UK folks ...
Thats a reference to a UK kids sports programme from my youth ... anyway ...
enough of this banter. You'll be wanting to know that this is all about 
DPMI ...)
</p>

<sect1><heading>Functions in dosext/dpmi/dpmi.c</heading>

<p>These are the functions defined in dosext/dpmi/dpmi.c.</p>

<sect2><heading>dpmi_control</heading>


<p>
 
 This function is similar to the vm86() syscall in the kernel and
 switches to dpmi code.

 
</p>
</sect2>
<sect2><heading>run_pm_int</heading>


<p>
 
 This routine is used for running protected mode hardware
 interrupts.
 run_pm_int() switches to the locked protected mode stack
 and calls the handler. If no handler is installed the
 real mode interrupt routine is called.

 
</p>
</sect2>
<sect2><heading>run_pm_dos_int</heading>


<p>
 
 This routine is used for reflecting the software
 interrupts 0x1c, 0x23 and 0x24 to protected mode.

 
</p>
</sect2>
<sect2><heading>do_default_cpu_exception</heading>


<p>
 
 This is the default CPU exception handler.
 Exceptions 0, 1, 2, 3, 4, 5 and 7 are reflected
 to real mode. All other exceptions are terminating the client
 (and may be dosemu too :-)).

 
</p>
</sect2>
<sect2><heading>do_cpu_exception</heading>


<p>
 
 This routine switches to the locked protected mode stack,
 disables interrupts and calls the DPMI client exception handler.
 If no handler is installed the default handler is called.

 
</p>
</sect2>
<sect2><heading>dpmi_fault</heading>


<p>
 
 This is the brain of DPMI. All CPU exceptions are first
 reflected (from the signal handlers) to this code.

 Exception from nonprivileged instructions INT XX, STI, CLI, HLT
 and from WINDOWS 3.1 are handled here.

 All here unhandled exceptions are reflected to do_cpu_exception()

 Note for cpu-emu: exceptions generated from the emulator are handled
  here. 'Real' system exceptions (e.g. from an emulator fault) are
  redirected to emu_dpmi_fault() in fullemu mode

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in dosext/dpmi/dpmi.c</heading>

<p>
 We are caching ldt here for speed reasons and for Windows 3.1.
 I would love to have an readonly ldt-alias (located in the first
 16MByte for use with 16-Bit descriptors (WIN-LDT)). This is on my
 wish list for the kernel hackers (Linus mainly) :-))))))).
 
 
</p><p>-----</p>

<p> DPMI is designed such that the stack change needs a task switch.
 We are doing it via an SIGSEGV - instead of one task switch we have
 now four :-(.
 Arrgh this is the point where I should start to include DPMI stuff
 in the kernel, but then we could include the rest of dosemu too.
 Would Linus love this? I don't :-((((.
 Anyway I would love to see first a working DPMI port, maybe we
 will later (with version 0.9 or similar :-)) start with it to
 get a really fast dos emulator...............
 
 NOTE: Using DIRECT_DPMI_CONTEXT_SWITCH we avoid these 4  taskswitches
       actually doing 0. We don't need a 'physical' taskswitch
       (not having different TSS for us and DPMI), we only need a complete
       register (context) replacement. For back-switching, however, we need
       the sigcontext technique, so we build a proper sigcontext structure
       even for 'hand made taskswitch'. (Hans Lermen, June 1996)

 dpmi_control is called only from dpmi_run when in_dpmi_dos_int==0

 
</p><p>-----</p>

<p> Hopefully the below LAR can serve as a replacement for the KERNEL_LDT,
 which we are abandoning now. Especially the 'accessed-bit' will get
 updated in the ldt-cache with the code below.
 Most DPMI-clients fortunately _are_ using LAR also to get this info,
 however, some do not. Some of those which do _not_, at least use the
 DPMI-GetDescriptor function, so this may solve the problem.
                      (Hans Lermen, July 1996)
 
</p><p>-----</p>

<p> Here we handle all prefixes prior switching to the appropriate routines
 The exception CS:EIP will point to the first prefix that effects the
 the faulting instruction, hence, 0x65 0x66 is same as 0x66 0x65.
 So we collect all prefixes and remember them.
 - Hans Lermen
 
</p>
</sect1>

<sect1><heading>Items for Fixing in dosext/dpmi/dpmi.c</heading>

<p>
 We shouldn't return to dosemu code if IF=0, but it helps - WHY? */

</p>
</sect1>

</sect>

<sect><heading>The Video group of Modules</heading>
<p>
All of the Video handling code is in the "video" subdirectory.

There is one file for each video card or chipset and the master file. To
Add a new card, it needs a set of save &amp; restore routines putting in a file
here.
</p>

<sect1><heading>Functions in env/video/video.c</heading>

<p>These are the functions defined in env/video/video.c.</p>

<sect2><heading>video_init</heading>


<p>
 
  Set pointer to correct structure of functions to initialize, close,
  etc... video routines.

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in env/video/video.c</heading>

<p>
 Here the sleeping lion will be awoken and eat much of CPU time !!!
 
 The result of setting VM86_SCREEN_BITMAP (at state of Linux 1.1.56):
   Each vm86 call will set 32 pages of video mem RD-only
    (there may be 1000000 per second)
   Write access to RD-only page results in page-fault (mm/memory.c),
   which will set a bit in current-&gt;screen_bitmap and calls do_wp_page()
   which does __get_free_page(GFP_KERNEL) but frees it immediatly, 
   because copy-on-write is not neccessary and sets RD/WR for the page.
   (this could happen 32000000 per second, if the CPU were fast enough)
 It would be better to get the DIRTY-bit directly from the page table,
 isn't it?  A special syscall in emumodule could do this.
 
</p><p>-----</p>

<p> reserve_video_memory()
 
 This procedure is trying to eke out all the UMB blocks possible to
 maximize your memory under DOSEMU.  If you know about dual monitor
 setups, you can contribute by putting in the correct graphics page
 address values.
 
</p>
</sect1>

<sect1><heading>Functions in env/video/vgaemu.c</heading>

<p>These are the functions defined in env/video/vgaemu.c.</p>

<sect2><heading>VGA_emulate_outb</heading>


<p>
 
 Emulates writes to VGA ports.
 This is a hardware emulation function.

</p><p>Arguments are:&nl;
<itemize>
<item>  port  - The port being written to.</item>
<item>  value - The value written,</item>
</itemize>
</p>
</sect2>
<sect2><heading>VGA_emulate_inb</heading>


<p>
 
 Emulates reads from VGA ports.
 This is a hardware emulation function.

</p><p>Arguments are:&nl;
<itemize>
<item>  port  - The port being read from.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_fault</heading>


<p>
 
 vga_emu_fault() is used to catch video access, and handle it.
 This function is called from arch/linux/async/sigsegv.c::dosemu_fault1().
 The sigcontext_struct is defined in include/cpu.h.
 Now it catches only changes in a 4K page, but maybe it is useful to
 catch each video access. The problem when you do that is, you have to 
 simulate each instruction which could write to the video memory.
 It is easy to get the place where the exception happens (scp-&gt;cr2),
 but what are those changes?
 An other problem is, it could eat a lot of time, but it does now also.

 MODIFICATION: VGA mode 12h under X is supported in exactly the
 way that was suggested above.  Not every instruction needs to be
 simulated in order to make this feature useful, just the ones used to
 access video RAM by key applications (Borland BGI, Protel, etc.).

 MODIFICATION: all VGA modes now work and almost all instructions are
 simulated.

</p><p>Arguments are:&nl;
<itemize>
<item>  scp - A pointer to a struct sigcontext_struct holding some relevant data.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_init</heading>


<p>
 
 vga_emu_init() must be called before using the VGAEmu functions.
 It is only called from env/video/X.c::X_init() at the moment.
 This function basically initializes the global variable `vga' and
 allocates the VGA memory.

 It does in particular *not* map any memory into the range
 0xa0000 - 0xc0000, this is done as part of a VGA mode switch.

 There should be an accompanying vga_emu_done().

</p><p>Arguments are:&nl;
<itemize>
<item>  vedt - Pointer to struct describing the type of display we are actually</item>
<item>         attached to.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_update</heading>


<p>
 
 vga_emu_update() scans the VGA memory for dirty (= written to since last
 update) pages and returns the changed area in *veut. See the definition
 of vga_emu_update_type in env/video/vgaemu_inside.h for details.

 You will need to call this function repeatedly until it returns 0 to
 grab all changes. You can specify an upper limit for the size of the
 area that will be returned using `veut-&gt;max_max_len' and `veut-&gt;max_len'.
 See the example in env/video/X.c how this works.
 
 If the return value of vga_emu_update() is &gt;= 0, it is the number of changed
 pages, -1 means there are still changed pages but the maximum update chunk size
 (`veut-&gt;max_max_len') was exceeded.

 This function does in its current form not work for Hercules modes; it
 does, however work for text modes, although this feature is currently
 not used.

</p><p>Arguments are:&nl;
<itemize>
<item>  veut - A pointer to a vga_emu_update_type object holding all relevant info.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vgaemu_switch_plane</heading>


<p>
 
 vgaemu_switch_plane() maps the specified plane.

 This function returns True on success and False on error, usually
 indicating an invalid bank number.

</p><p>Arguments are:&nl;
<itemize>
<item>  plane (0..3) - The plane to map.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_switch_bank</heading>


<p>
 
 vga_emu_switch_bank() is used to emulate video-bankswitching.

 This function returns True on success and False on error, usually
 indicating an invalid bank number.

</p><p>Arguments are:&nl;
<itemize>
<item>  bank - The bank to switch to.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_find_mode</heading>


<p>
 
 Searches a video mode with the requested mode number.

 The search starts with the mode *after* the mode `vmi' points to.
 If `vmi' == NULL, starts at the beginning of the internal mode table.
 `mode' may be a standard VGA mode number (0 ... 0x7f) or a
 VESA mode number (&gt;= 0x100). The mode number may have its don't-clear-bit
 (bit 7 or bit 15) or its use-lfb-bit (bit 14) set.
 The special mode number -1 will match any mode and may be used to
 scan through the whole table.

 Returns NULL if no mode was found and a pointer into the mode table
 otherwise. The returned pointer is a suitable argument for subsequent
 calls to this function.

 You should (and can) access the mode table only through this function.

</p><p>Arguments are:&nl;
<itemize>
<item>  mode   - video mode.</item>
<item>  vmi    - pointer into internal mode list</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_setmode</heading>


<p>
 
 Set a video mode.

 Switches to `mode' with text sizes `width' and `height' or (if no such
 mode was found) at least `width' and `height'.

</p><p>Arguments are:&nl;
<itemize>
<item>  mode   - The new video mode.</item>
<item>  width  - Number of text columns.</item>
<item>  height - Number of text rows.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_set_textsize</heading>


<p>
 
 Sets the text mode resolution. Typically called after
 a font change.

</p><p>Arguments are:&nl;
<itemize>
<item>  width  - Number of text columns.</item>
<item>  height - Number of text rows.</item>
</itemize>
</p>
</sect2>
<sect2><heading>dirty_all_video_pages</heading>


<p>
 
 Marks the whole VGA memory as modified.

 
</p>
</sect2>
<sect2><heading>dirty_all_vga_colors</heading>


<p>
 
 Marks all colors as changed.

 
</p>
</sect2>
<sect2><heading>changed_vga_colors</heading>


<p>
 
 Checks DAC and Attribute Controller to find all colors with
 changed RGB-values.
 Returns number of changed colors.
 Note: the list _must_ be large enough, that is, have at least
 min(256, (1 &lt;&lt; vga.pixel_size)) entries!

</p><p>Arguments are:&nl;
<itemize>
<item>  de - list of DAC entries to store changed colors in</item>
</itemize>
</p>
</sect2>
<sect2><heading>vgaemu_adj_cfg</heading>


<p>
 
 Adjust VGAEmu according to VGA register changes.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in env/video/vesa.c</heading>

<p>These are the functions defined in env/video/vesa.c.</p>

<sect2><heading>vbe_init</heading>


<p>
 
 Initializes the VGA/VBE BIOS and the VBE support.

</p><p>Arguments are:&nl;
<itemize>
<item>  vedt - Pointer to struct describing the type of display we are actually</item>
<item>         attached to.</item>
</itemize>
</p>
</sect2>
<sect2><heading>do_vesa_int</heading>


<p>
 
 This is the VESA interrupt handler.

 It is called from base/bios/int10.c::int10(). The VESA interrupt is called
 with 0x4f in AH and the function number (0x00 ... 0x10) in AL.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in env/video/attremu.c</heading>

<p>These are the functions defined in env/video/attremu.c.</p>

<sect2><heading>Attr_init</heading>


<p>
 
 Initializes the attribute controller.
 This is an interface function.

 
</p>
</sect2>
<sect2><heading>Attr_get_entry</heading>


<p>
 
 Directly reads the Attribute Controller's registers.
 This is an interface function.

 
</p>
</sect2>
<sect2><heading>Attr_set_entry</heading>


<p>
 
 Directly sets the Attribute Controller's registers.
 This is an interface function.

 
</p>
</sect2>
<sect2><heading>Attr_read_value</heading>


<p>
 
 Emulates reads from the attribute controller.
 This is a hardware emulation function.

 
</p>
</sect2>
<sect2><heading>Attr_write_value</heading>


<p>
 
 Emulates writes to attribute controller combined index and data
 register. Read VGADOC for details.
 This is a hardware emulation function.

 
</p>
</sect2>
<sect2><heading>Attr_get_index</heading>


<p>
 
 Returns the current index of the attribute controller.
 This is a hardware emulation function, though in fact this function
 is undefined in a real attribute controller.
 Well, it is exactly what my VGA board (S3) does. -- sw
 This is a hardware emulation function.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in env/video/dacemu.c</heading>

<p>These are the functions defined in env/video/dacemu.c.</p>

<sect2><heading>DAC_init</heading>


<p>
 
 Initializes the DAC.
 It depends on a correct value in vga.pixel_size. This function should be
 called during VGA mode initialization.
 This is an interface function.

 
</p>
</sect2>
<sect2><heading>DAC_set_width</heading>


<p>
 
 Sets the DAC width. Typical values are 6 or 8 bits.
 In theory, we support other values as well (untested).
 This is an interface function.

 
</p>
</sect2>
<sect2><heading>DAC_get_entry</heading>


<p>
 
 Returns a complete DAC entry (r, g, b).
 Don't forget to set DAC_entry.index first!
 This is an interface function.

 
</p>
</sect2>
<sect2><heading>DAC_set_entry</heading>


<p>
 
 Sets a complete DAC entry (r,g,b).
 This is an interface function.

 
</p>
</sect2>
<sect2><heading>DAC_rgb2gray</heading>


<p>
 
 Converts a DAC register's RGB values to gray scale.
 This is an interface function.

 
</p>
</sect2>
<sect2><heading>DAC_set_read_index</heading>


<p>
 
 Specifies which palette entry is read.
 This is a hardware emulation function.

 
</p>
</sect2>
<sect2><heading>DAC_set_write_index</heading>


<p>
 
 Specifies which palette entry is written.
 This is a hardware emulation function.

 
</p>
</sect2>
<sect2><heading>DAC_read_value</heading>


<p>
 
 Read a value from the DAC. Each read will cycle through the registers for
 red, green and blue. After a ``blue read'' the read index will be 
 incremented. Read VGADOC4 if you want to know more about the DAC.
 This is a hardware emulation function.

 
</p>
</sect2>
<sect2><heading>DAC_write_value</heading>


<p>
 
 Write a value to the DAC. Each write will cycle through the registers for
 red, green and blue. After a ``blue write'' the write index will be
 incremented.
 This is a hardware emulation function.

 
</p>
</sect2>
<sect2><heading>DAC_get_pel_mask</heading>


<p>
 
 Returns the current PEL mask. Note that changed_vga_colors() already
 applies the PEL mask; so applications should not worry too much about it.
 This is a hardware emulation function.

 
</p>
</sect2>
<sect2><heading>DAC_set_pel_mask</heading>


<p>
 
 Sets the PEL mask and marks all DAC entries as dirty.
 This is a hardware emulation function.

 
</p>
</sect2>
<sect2><heading>DAC_get_state</heading>


<p>
 
 Returns the current state of the DAC.
 This is a hardware emulation function.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in env/video/crtcemu.c</heading>

<p>These are the functions defined in env/video/crtcemu.c.</p>

<sect2><heading>CRTC_init</heading>


<p>
 
 Initializes the CRT Controller.
 This is an interface function.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in env/video/dualmon.c</heading>

<p>These are the functions defined in env/video/dualmon.c.</p>

<sect2><heading>MDA_init</heading>


<p>
 
  Initializes the monochrome card. First detects which monochrome
  card is used, because the Hercules RamFont and the Hercules InColor
  need one more register to be initialized. If there is no monochrome
  card at all, we just think there is one and poke an peek in the void.
  After the detection the card is initialized.

 returns: 
  nothing

</p><p>Arguments are:&nl;
<itemize>
<item>   none</item>
</itemize>
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in env/video/dualmon.c</heading>

<p>
 After MDA_init() the VGA is configured, something in video.c 
 or console.c "reprograms" the monochrome card again in such a way 
 that I always have to run hgc.com before I can use any program that 
 uses the monochrome card. I've spent a day trying to find it, but I 
 can't figure out. Something is writing to one of the following ports: 
 0x3b4, 0x3b5, 0x3b8, 0x3b9, 0x3ba, 0x3bb, 0x3bf.
 The problem occurs at (at least) the following 2 systems:
 
  - AMD 386DX40, Trident 9000/512Kb ISA, Hercules Graphics Card Plus
  - Intel 486DX2/66, Cirrus Logic 5426/1Mb VLB, Hercules clone

 The problem doesn't occur when I start dosemu from a telnet connection
 or from a VT100 terminal. (Erik Mouw, jakmouw@et.tudelft.nl)

 
</p>
</sect1>

<sect1><heading>Functions in env/video/vgaemu.c</heading>

<p>These are the functions defined in env/video/vgaemu.c.</p>

<sect2><heading>VGA_emulate_outb</heading>


<p>
 
 Emulates writes to VGA ports.
 This is a hardware emulation function.

</p><p>Arguments are:&nl;
<itemize>
<item>  port  - The port being written to.</item>
<item>  value - The value written,</item>
</itemize>
</p>
</sect2>
<sect2><heading>VGA_emulate_inb</heading>


<p>
 
 Emulates reads from VGA ports.
 This is a hardware emulation function.

</p><p>Arguments are:&nl;
<itemize>
<item>  port  - The port being read from.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_fault</heading>


<p>
 
 vga_emu_fault() is used to catch video access, and handle it.
 This function is called from arch/linux/async/sigsegv.c::dosemu_fault1().
 The sigcontext_struct is defined in include/cpu.h.
 Now it catches only changes in a 4K page, but maybe it is useful to
 catch each video access. The problem when you do that is, you have to 
 simulate each instruction which could write to the video memory.
 It is easy to get the place where the exception happens (scp-&gt;cr2),
 but what are those changes?
 An other problem is, it could eat a lot of time, but it does now also.

 MODIFICATION: VGA mode 12h under X is supported in exactly the
 way that was suggested above.  Not every instruction needs to be
 simulated in order to make this feature useful, just the ones used to
 access video RAM by key applications (Borland BGI, Protel, etc.).

 MODIFICATION: all VGA modes now work and almost all instructions are
 simulated.

</p><p>Arguments are:&nl;
<itemize>
<item>  scp - A pointer to a struct sigcontext_struct holding some relevant data.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_init</heading>


<p>
 
 vga_emu_init() must be called before using the VGAEmu functions.
 It is only called from env/video/X.c::X_init() at the moment.
 This function basically initializes the global variable `vga' and
 allocates the VGA memory.

 It does in particular *not* map any memory into the range
 0xa0000 - 0xc0000, this is done as part of a VGA mode switch.

 There should be an accompanying vga_emu_done().

</p><p>Arguments are:&nl;
<itemize>
<item>  vedt - Pointer to struct describing the type of display we are actually</item>
<item>         attached to.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_update</heading>


<p>
 
 vga_emu_update() scans the VGA memory for dirty (= written to since last
 update) pages and returns the changed area in *veut. See the definition
 of vga_emu_update_type in env/video/vgaemu_inside.h for details.

 You will need to call this function repeatedly until it returns 0 to
 grab all changes. You can specify an upper limit for the size of the
 area that will be returned using `veut-&gt;max_max_len' and `veut-&gt;max_len'.
 See the example in env/video/X.c how this works.
 
 If the return value of vga_emu_update() is &gt;= 0, it is the number of changed
 pages, -1 means there are still changed pages but the maximum update chunk size
 (`veut-&gt;max_max_len') was exceeded.

 This function does in its current form not work for Hercules modes; it
 does, however work for text modes, although this feature is currently
 not used.

</p><p>Arguments are:&nl;
<itemize>
<item>  veut - A pointer to a vga_emu_update_type object holding all relevant info.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vgaemu_switch_plane</heading>


<p>
 
 vgaemu_switch_plane() maps the specified plane.

 This function returns True on success and False on error, usually
 indicating an invalid bank number.

</p><p>Arguments are:&nl;
<itemize>
<item>  plane (0..3) - The plane to map.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_switch_bank</heading>


<p>
 
 vga_emu_switch_bank() is used to emulate video-bankswitching.

 This function returns True on success and False on error, usually
 indicating an invalid bank number.

</p><p>Arguments are:&nl;
<itemize>
<item>  bank - The bank to switch to.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_find_mode</heading>


<p>
 
 Searches a video mode with the requested mode number.

 The search starts with the mode *after* the mode `vmi' points to.
 If `vmi' == NULL, starts at the beginning of the internal mode table.
 `mode' may be a standard VGA mode number (0 ... 0x7f) or a
 VESA mode number (&gt;= 0x100). The mode number may have its don't-clear-bit
 (bit 7 or bit 15) or its use-lfb-bit (bit 14) set.
 The special mode number -1 will match any mode and may be used to
 scan through the whole table.

 Returns NULL if no mode was found and a pointer into the mode table
 otherwise. The returned pointer is a suitable argument for subsequent
 calls to this function.

 You should (and can) access the mode table only through this function.

</p><p>Arguments are:&nl;
<itemize>
<item>  mode   - video mode.</item>
<item>  vmi    - pointer into internal mode list</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_setmode</heading>


<p>
 
 Set a video mode.

 Switches to `mode' with text sizes `width' and `height' or (if no such
 mode was found) at least `width' and `height'.

</p><p>Arguments are:&nl;
<itemize>
<item>  mode   - The new video mode.</item>
<item>  width  - Number of text columns.</item>
<item>  height - Number of text rows.</item>
</itemize>
</p>
</sect2>
<sect2><heading>vga_emu_set_textsize</heading>


<p>
 
 Sets the text mode resolution. Typically called after
 a font change.

</p><p>Arguments are:&nl;
<itemize>
<item>  width  - Number of text columns.</item>
<item>  height - Number of text rows.</item>
</itemize>
</p>
</sect2>
<sect2><heading>dirty_all_video_pages</heading>


<p>
 
 Marks the whole VGA memory as modified.

 
</p>
</sect2>
<sect2><heading>dirty_all_vga_colors</heading>


<p>
 
 Marks all colors as changed.

 
</p>
</sect2>
<sect2><heading>changed_vga_colors</heading>


<p>
 
 Checks DAC and Attribute Controller to find all colors with
 changed RGB-values.
 Returns number of changed colors.
 Note: the list _must_ be large enough, that is, have at least
 min(256, (1 &lt;&lt; vga.pixel_size)) entries!

</p><p>Arguments are:&nl;
<itemize>
<item>  de - list of DAC entries to store changed colors in</item>
</itemize>
</p>
</sect2>
<sect2><heading>vgaemu_adj_cfg</heading>


<p>
 
 Adjust VGAEmu according to VGA register changes.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in env/video/instremu.c</heading>

<p>These are the functions defined in env/video/instremu.c.</p>

<sect2><heading>instr_len</heading>


<p>
 
 Returns the length of an instruction; 0 if it could not
 be determined.

 
</p>
</sect2>
<sect2><heading>instr_sim</heading>


<p>
 
 instr_sim is used to simulate instructions that access the
 VGA video memory in planar modes when using X as the video output
 device.  

 It is necessary to do this in order to simulate the effects 
 of the hardware VGA controller in X mode.

 If the return value is 0, it means the instruction was not one
 that for which a simulation is provided.  The return value is 1 for success,
 but the function exits because we need to go back to the DOSEMU's main loop
 or count runs out.

</p><p>Arguments are:&nl;
<itemize>
<item>  x86: the structure holding everything about the cpu-state we need.</item>
</itemize>
</p>
</sect2>
<sect2><heading>instr_emu</heading>


<p>
 
 instr_emu is the main interface to instr_sim. It puts the processor
 state in the x86 structure.

</p><p>Arguments are:&nl;
<itemize>
<item>  scp - A pointer to a struct sigcontext_struct holding some relevant data.</item>
<item>  pmode - flags protected mode</item>
<item>  cnt - number of instructions to be simulated</item>
</itemize>
</p>
</sect2>
</sect1>

</sect>

<sect><heading>The New_Keyboard group of Modules</heading>
<p>
Most of the New Keyboard handling code is in the "plugin/kbd_unicode" subdirectory.

</p>

<sect1><heading>Functions in plugin/kbd_unicode/serv_xlat.c</heading>

<p>These are the functions defined in plugin/kbd_unicode/serv_xlat.c.</p>

<sect2><heading>compute_keynum</heading>


<p>
 
 The task of compute_keynum() is to 'collect' keyboard bytes (e.g.
 0xe0 prefixes) until it thinks it has assembled an entire keyboard
 event. The entire keyboard event is then returned, otherwise
 NUM_VOID is returned.
 
 
</p>
</sect2>
<sect2><heading>translate_key</heading>


<p>
 translate_key takes a keysym event and calculates the appropriate
 bios translation.
 
 As a side effect translate_key updates the apropriate pieces of state
 to reflect the current keyboard state.
 
 Calling translate_key twice on the same data is likely to be hazardous.

 
</p>
</sect2>
<sect2><heading>put_rawkey</heading>


<p>
 
 This function sends a raw keycode byte, e.g. read directly from the hardware,
 to DOS. It is both queued for the port60h emulation and processed for the
 BIOS keyboard buffer, using the national translation tables etc.

 For DOS applications using int16h we will therefore not have to load
 KEYB.EXE, others (e.g. games) need their own drivers anyway.

 This function is used if we are at the console and config.rawkeyboard=on.

 
</p>
</sect2>
<sect2><heading>move_keynum</heading>


<p>
 
 This does all the work of sending a key event to DOS.
 Either pressing a key releasing one.  The key to move is
 the key specified by keynum.
  
   keynum - the keynum from keynum.h indicating a physical key
   make  - TRUE for key press, FALSE for release

 Applications using int16h will always see the appropriate ASCII code
 for the given keyboard key and the current keyboard state.  All the
 chracter translation is done for you to keep from reporting
 inconsistent key events.

 An emulated hardware scancode is also sent to port60h.

 Note that you have to send both MAKE (press) and BREAK (release) events.
 If no BREAK codes are available (e.g. terminal mode), send them
 immediately after the MAKE codes.

 
</p>
</sect2>
<sect2><heading>keysym_to_keynum</heading>


<p>
 
 Allows peeking into the keytables.
 This returns the keynum a given keysym sits on.

 
</p>
</sect2>
<sect2><heading>move_key</heading>


<p>
 
 This does all the work of sending a key event to DOS.
 Either pressing a key releasing one.  The key to move is
 the key that is labeled with the specified keysym.
  
   key  - the keysym, one of the KEY_ constants from new-kbd.h
   make  - TRUE for key press, FALSE for release

 Applications using int16h will always see the appropriate ASCII code
 for the given keyboard key and the current keyboard state.  All the
 chracter translation is done for you to keep from reporting
 inconsistent key events.

 An emulated hardware scancode is also sent to port60h.

 Note that you have to send both MAKE (press) and BREAK (release) events.
 If no BREAK codes are available (e.g. terminal mode), send them
 immediately after the MAKE codes.

 
</p>
</sect2>
<sect2><heading>put_symbol</heading>


<p>
 
 This does all the work of sending a key event to DOS.
   sym -- The unicode value of the symbol you want to send

 Applications using int16h will always see the symbol passed
 here, if it is representable in the current dos character set.  The
 appropriate scancodes are generated automatically to keep the
 keyboard code consistent.  

 An emulated hardware scancode is also sent to port60h.

 Note that you have to send both MAKE (press) and BREAK (release) events.
 If no BREAK codes are available (e.g. terminal mode), send them
 immediately after the MAKE codes.

 
</p>
</sect2>
<sect2><heading>put_modified_symbol</heading>


<p>
 
 This does all the work of sending a key event to DOS.
   sym -- The unicode value of the symbol you want to send
   modifiers  -- modifiers like alt etc you what to change your symbol with.

 This function is a concession to the reality, in which key events
 are a composed of active modifiers, and a key label.

 This function behaves as put_symbol does, except before pressing
 the key it adds the specified modifiers to the modifiers it would
 normally use.
 
 For cases where the symbol can only be created by an alt&num; combination
 or by pressing a dead key (Basically any case where more than one
 key is requried, after setting the shiftstate) it gives up and just
 sends the symbol.

 Note that you have to send both MAKE (press) and BREAK (release) events.
 If no BREAK codes are available (e.g. terminal mode), send them
 immediately after the MAKE codes.

 
</p>
</sect2>
<sect2><heading>get_shiftstate</heading>


<p>
 
 This simply reads the keyboard server's shift state.
 
 This is intended to be used in conjunction with set_shiftstate
 to sync up a shiftstate with a source of key events.

 With the addition of this function the keyboard inteface is clean enough
 so if needed a completly different translation engine can be dropped in
 to support a totally different environment (windows or whatever).

 
</p>
</sect2>
<sect2><heading>set_shiftstate</heading>


<p>
 
 This simply sets the keyboard server's shift state.

 If there are shiftstate bits you want to keep fixed simply grab them with 
 get_shiftstate, before calling this function.

 This changes the keyboard flags by generating the appropriate 
 shift key make/break codes that normally come along with such
 changes. So this function should be safe in any context.

 Note also that you can't simply write to the shiftstate variable
 instead of using this function.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in plugin/kbd_unicode/keyb_clients.c</heading>

<p>These are the functions defined in plugin/kbd_unicode/keyb_clients.c.</p>

<sect2><heading>keyb_client_init</heading>


<p>
 
 Figures out which keyboard client to use and initialises it.
 
 First it calls the probe method to see if it should use the client,
 Then it call init to set that client up.

 If probe or init fails it trys another client.

 Eventually falling back to Keyboard_none a dummy client, which does nothing.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in plugin/kbd_unicode/keyb_none.c</heading>

<p>These are the functions defined in plugin/kbd_unicode/keyb_none.c.</p>

<sect2><heading>none_probe</heading>


<p>
 
 Succeed if we can run the dummy keyboard client, (we always can).
 but first try the other fall-back (slang keyboard)

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in plugin/kbd_unicode/keyb_raw.c</heading>

<p>These are the functions defined in plugin/kbd_unicode/keyb_raw.c.</p>

<sect2><heading>raw_keyboard_init</heading>


<p>
 
 Initialize the keyboard for RAW mode.
 
 
</p>
</sect2>
<sect2><heading>raw_keyboard_reset</heading>


<p>
 
 Reset the keyboard shiftstate to match the keyboard LED's
 
 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in plugin/term/keyb_slang.c</heading>

<p>These are the functions defined in plugin/term/keyb_slang.c.</p>

<sect2><heading>setup_pc_scancode_mode</heading>


<p>
 
 Initialize the keyboard in pc scancode mode.
 This functionality is ideal but rarely supported on a terminal.
 
 
</p>
</sect2>
<sect2><heading>exit_pc_scancode_mode</heading>


<p>
 
 Set the terminal back to a keyboard mode other
 programs can understand.
 
 
</p>
</sect2>
<sect2><heading>do_pc_scancode_getkeys</heading>


<p>
 
 Set the terminal back to a keyboard mode other
 programs can understand.
 
 
</p>
</sect2>
<sect2><heading>slang_keyb_init()</heading>


<p>
 
 Code is called at start up to set up the terminal line for non-raw mode.
 
 
</p>
</sect2>
<sect2><heading>slang_keyb_probe()</heading>


<p>
 
 Code is called at start up to see if we can use the slang keyboard.
 
 
</p>
</sect2>
</sect1>

</sect>

<sect><heading>The Old_Keyboard group of Modules</heading>
<p>
All of the Old Keyboard handling code is in the "plugin/keyboard" subdirectory.

Latest addition is SLANG.
</p>

</sect>

<sect><heading>The Misc group of Modules</heading>
<p>
These are the remaining important files, that do not really fit into another
group. These should not be dismissed as unimportant - rather, they are often
amongst the most important.
</p>

<sect1><heading>Functions in base/async/int.c</heading>

<p>These are the functions defined in base/async/int.c.</p>

<sect2><heading>int1a</heading>


<p>
 
 int 0x1A call

 This has (among other things) the calls that DOS makes to get/set its sense
 of time. On booting, DOS gets the RTC time and date with AH=2 and AH=4,
 after that it should use AH=0 calls to read the 'tick' counter from BIOS
 memory. Each time this crosses midnight, a flag is set that DOS uses to
 increment its date.

 Here we can now change the 'view' of time so the calls either return BIOS
 tick (most DOS like), read the PIT counter (avoids INT-8 changes) or gets
 LINUX time (most accurate for long term NTP-adjusted time keeping).

 
</p>
</sect2>
<sect2><heading>ms_dos</heading>


<p>
 
 int0x21 call

 we trap this for two functions: simulating the EMMXXXX0 device and
 fudging the CONFIG.XXX and AUTOEXEC.XXX bootup files.

 note that the emulation herein may cause problems with programs
 that like to take control of certain int 21h functions, or that
 change functions that the true int 21h functions use.  An example
 of the latter is ANSI.SYS, which changes int 10h, and int 21h
 uses int 10h.  for the moment, ANSI.SYS won't work anyway, so it's
 no problem.

 
</p>
</sect2>
<sect2><heading>run_caller_func(i, revect)</heading>


<p>
 
 This function runs the specified caller function in response to an
 int instruction.  Where i is the interrupt function to execute.

 revect specifies whether we call a non-revectored leaf interrupt function
 or a "watcher" that sits in between:
 the leaf interrupt function is called if cs:ip is at f000:i*10 or if
  (the int vector points there and the int is labelled non-revectored)
 otherwise the non-leaf interrupt function is called, which may chain
 through to the real interrupt function (if it returns 0)

 This function runs the instruction with the following model _CS:_IP is the
 address to start executing at after the caller function terminates, and
 _EFLAGS are the flags to use after termination.  For the simple case of an
 int instruction this is easy.  _CS:_IP = retCS:retIP and _FLAGS = retFLAGS
 as well equally the current values (retIP = curIP +2 technically).

 However if the function is called (from dos) by simulating an int instruction
 (something that is common with chained interrupt vectors) 
 _CS:_IP = BIOS_SEG:HLT_OFF(i) and _FLAGS = curFLAGS 
 while retCS, retIP, and retFlags are on the stack.  These I pop and place in
 the appropriate registers.  

 This functions actions certainly correct for functions executing an int/iret
 discipline.  And almost certianly correct for functions executing an
 int/retf&num;2 discipline (with flag changes), as an iret is always possilbe.
 However functions like dos int 0x25 and 0x26 executing with a int/retf will
 not be handled correctlty by this function and if you need to handle them
 inside dosemu use a halt handler instead.

 Finally there is a possible trouble spot lurking in this code.  Interrupts
 are only implicitly disabled when it calls the caller function, so if for
 some reason the main loop would be entered before the caller function returns
 wrong code may execute if the retFLAGS have interrupts enabled!  

 This is only a real handicap for sequences of dosemu code execute for long
 periods of time as we try to improve timer response and prevent signal queue
 overflows! -- EB 10 March 1997

 Grumble do to code that executes before interrupts, and the
 semantics of default_interupt, I can't implement this function as I
 would like.  In the tricky case of being called from dos by
 simulating an int instruction, I must leave retCS, retIP, on the
 stack.  But I can safely read retFlags so I do.  
 I pop retCS, and retIP just before returning to dos, as well as
 dropping the stack slot  that held retFlags.

 This improves consistency of interrupt handling, but not quite as
 much as if I could handle it the way I would like.
 -- EB 30 Nov 1997

 Trying to get it right now -- BO 25 Jan 2003

 This function returns 1 if it's completely finished (no need to run
 real_run_int()), otherwise 0.

 
</p>
</sect2>
<sect2><heading>DO_INT </heading>


<p>
 
 DO_INT is used to deal with interrupts returned to DOSEMU by the
 kernel.

 
</p>
</sect2>
<sect2><heading>setup_interrupts</heading>


<p>
 
 SETUP_INTERRUPTS is used to initialize the interrupt_function
 array which directs handling of interrupts in protected mode and
 also initializes the base vector for interrupts in real mode.

 
</p>
</sect2>
<sect2><heading>int_vector_setup</heading>


<p>
 
 Setup initial interrupts which can be revectored so that the kernel
 does not need to return to DOSEMU if such an interrupt occurs.

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in base/async/int.c</heading>

<p>
 Some video BIOSes need access to the PIT timer 2, and some
 (e.g. Matrox) directly read the timer output on port 0x61.
 If we don't allow video port access, this will be totally
 emulated; else, we give temporary access to the needed ports
 (timer at 0x42, timer config at 0x43 and timer out/speaker at 0x61),
 provided they were not previously enabled by SPKR_NATIVE - AV
 
</p><p>-----</p>

<p> Many video BIOSes use hi interrupt vector locations as
 scratchpad area - this is because they come before DOS and feel
 safe to do it. But we are initializing vectors before video, so
 this only causes trouble. I assume no video BIOS will ever:
 - change vectors &lt; 0xe0 (0:380-0:3ff area)
 - change anything in the vector area _after_ installation - AV
 
</p>
</sect1>

<sect1><heading>Functions in arch/linux/async/sigsegv.c</heading>

<p>These are the functions defined in arch/linux/async/sigsegv.c.</p>

<sect2><heading>dosemu_fault(int, struct sigcontext_struct);</heading>


<p>
 
 All CPU exceptions (except 13=general_protection from V86 mode,
 which is directly scanned by the kernel) are handled here.

 
</p>
</sect2>
<sect2><heading>print_exception_info</heading>


<p>
 
 Prints information about an exception: exception number, error code,
 address, reason, etc.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in arch/linux/async/signal.c</heading>

<p>These are the functions defined in arch/linux/async/signal.c.</p>

<sect2><heading>NEWSETQSIG</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  sig - the signal to have a handler installed to.</item>
<item>  fun - the signal handler function to install</item>
</itemize>
  All signals that wish to be handled properly in context with the
 execution of vm86() mode, and signals that wish to use non-reentrant
 functions should add themselves to the ADDSET_SIGNALS_THAT_QUEUE define
 and use SETQSIG(). To that end they will also need to be set up in an
 order such as SIGIO.

 
</p>
</sect2>
<sect2><heading>SIG_init</heading>


<p>
 
 The IRQ numbers to monitor are taken from config.sillyint, each bit
 corresponding to one IRQ. The higher 16 bit are defining the use of
 SIGIO
 
 
</p>
</sect2>
<sect2><heading>signal_init</heading>


<p>
 
  Initialize the signals to have NONE being blocked.
 Currently this is NOT of much use to DOSEMU.

 
</p>
</sect2>
<sect2><heading>handle_signals</heading>


<p>
 
  Due to signals happening at any time, the actual work to be done 
 because a signal occurs is done here in a serial fashion.

 The concept, should this eventualy work, is that a signal should only
 flag that it has occurred and let DOSEMU deal with it in an orderly 
 fashion as it executes the rest of it's code.

 
</p>
</sect2>
<sect2><heading>SIGNAL_save</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  context     - signal context to save.</item>
<item>  signal_call - signal handling routine to be called.</item>
</itemize>
  Save into an array structure queue the signal context of the current
 signal as well as the function to call for dealing with this signal.
 This is a queue because any signal may occur multiple times before
 DOSEMU deals with it down the road.

 
</p>
</sect2>
<sect2><heading>SIGIO_call</heading>


<p>
 
  Whenever I/O occurs on devices allowing SIGIO to occur, DOSEMU
 will be flagged to run this call which inturn checks which 
 fd(s) was set and execute the proper routine to get the I/O
 from that device.

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in arch/linux/async/signal.c</heading>

<p>
 We assume system call restarting... under linux 0.99pl8 and earlier,
 this was the default.  SA_RESTART was defined in 0.99pl8 to explicitly
 request restarting (and thus does nothing).  However, if this ever
 changes, I want to be safe
 
</p><p>-----</p>

<p> Check for keyboard coming from client
  For now, first byte is interrupt requests from Client 
 
</p>
</sect1>

<sect1><heading>Functions in base/misc/disks.c</heading>

<p>These are the functions defined in base/misc/disks.c.</p>

<sect2><heading>disk_init</heading>


<p>
 
  Test by opening all floppies/hardrives configured.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in base/dev/misc/timers.c</heading>

<p>These are the functions defined in base/dev/misc/timers.c.</p>

<sect2><heading>initialize_timers</heading>


<p>
 
 ensure the 0x40 port timer is initially set correctly

 
</p>
</sect2>
<sect2><heading>timer_tick</heading>


<p>
 
  Every time we get a TIMER signal from Linux, this procedure is called.
  It checks to see if we should queue a timer interrupt based on the
  current values.

 
</p>
</sect2>
<sect2><heading>do_sound</heading>


<p>
 
 do_sound handles the _emulated_ mode pc-speaker emulation.  

 As far as I can determine all cases of the pc-speaker are now
 emulated.  But I am not sure where Rainer Zimmerman got his
 (pit&lsqb;2&rsqb;.mode == 2) || (pit&lsqb;2&rsqb;.mode == 3) test in the original
 implementation, it doesn't seem to cause problems though.

 The implementation of speaker_on &amp; speaker_off can be found in 
 src/base/speaker.c

 Major Changes from version written by Rainter Zimmerman.

 o Added support for programs that control the directly through bit 1
   of port61. 

 o Added a generic interface to allow multiple speaker backends.

 o Implemented X speaker code so the emulated speaker now works in X.

 --EB 21 September 1997
 
</p>
</sect2>
<sect2><heading>timer_int_engine</heading>


<p>
 
 This is experimental TIMER-IRQ CHAIN code!
 This is a function to determine whether it is time to invoke a
 new timer irq 0 event.  Normally it is 18 times a second, but
 many video games set it to 100 times per second or more.  Since
 the kernel cannot keep an accurate timer interrupt, the job of this
 routine is to perform a chained timer irq 0 right after the previous
 timer irq 0.  This routine should, ideally, be called right after
 the end of a timer irq, if possible.

 This would speed up high frequency timer interrupts if this code
 can be converted into an assembly macro equivalent!

 PLEASE NOTE

 This code has been replaced by interrupt scheduling code in pic.
 The result is that we simply call pic_sched and run the dos interrupt.
 If the new code causes no problems, I'll revise this section permanently. 

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in base/misc/dos2linux.c</heading>

<p>These are the functions defined in base/misc/dos2linux.c.</p>

<sect2><heading>run_unix_command</heading>


<p>
 
  Runs a command and prints the (stdout and stderr) output on the dosemu 
  screen.

</p><p>Return values mean:&nl;
</p><p>Arguments are:&nl;
<itemize>
<item>    buffer - string with command to execute</item>
</itemize>
</p>
</sect2>
</sect1>

<sect1><heading>Functions in base/misc/ioctl.c</heading>

<p>These are the functions defined in base/misc/ioctl.c.</p>

<sect2><heading>io_select_init</heading>


<p>
 
 Initialize fd_sets to NULL for both SIGIO and NON-SIGIO.
 
 
</p>
</sect2>
<sect2><heading>add_to_io_select</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  fd - File handle to add to select statment</item>
<item>  want_sigio - want SIGIO (1) if it's available, or not (0).</item>
</itemize>
 Add file handle to one of 2 select FDS_SET's depending on
 whether the kernel can handle SIGIO.
 
 
</p>
</sect2>
<sect2><heading>remove_from_io_select</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  fd - File handle to remove from select statment. </item>
<item>  used_sigio - used SIGIO (1) if it's available, or not (0).</item>
</itemize>
 Remove a file handle from one of 2 select FDS_SET's depending
 on whether the kernel can handle SIGIO.
 
 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in base/dev/misc/lpt.c</heading>

<p>These are the functions defined in base/dev/misc/lpt.c.</p>

<sect2><heading>printer_init</heading>


<p>
 
  Initialize printer control structures

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in base/dev/misc/pci.c</heading>

<p>These are the functions defined in base/dev/misc/pci.c.</p>

<sect2><heading>pci_read_header</heading>


<p>
 
 Use standard 32-bit (type 1) access method to read PCI
 configuration space data

 
</p>
</sect2>
<sect2><heading>pci_setup</heading>


<p>
 
 Register standard PCI ports 0xcf8-0xcff

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in base/dev/misc/joystick.c</heading>

<p>These are the functions defined in base/dev/misc/joystick.c.</p>

<sect2><heading>joy_latency_over</heading>


<p>
 
 Tells DOSEMU whether or not it is time to update its internal status
 of the joystick (for nonblocking reads only).

 DOS programs read/poll from the joystick port hundreds of thousands of
 times per second so the idea is that we really don't need to read from
 Linux for every such query (increasing performance by about 40&percnt;) because:

 1. humans are incapable of changing the status of the joystick
    (moving, pressing buttons) more than about 10 times per second

 2. no one will not notice a delay in DOS registering the joystick status
    (if it is in the order of a few milliseconds)

 Of course, this means that you should not set joy_latency in dosemu.conf
 to more than 1000/(&num;times I can press a button/move joy per second * 2),
 unless you want DOSEMU to miss quick axis/button changes and want to
 wait a ridiculous amount of time before DOSEMU registers any changes at
 all.

 
</p>
</sect2>
<sect2><heading>joy_emu_button_set</heading>


<p>
 
 Update the button status for each joystick.

 We must perform "button mapping" if only the first joystick is enabled
 i.e. we are required to map the "excessive" buttons (&gt;2) from the first
 joystick onto the second:

	a) 3rd button of 1st joy --&gt; 1st button of 2nd joy

	b) 4th button of 1st joy --&gt; 2nd button of 2nd joy

 
</p>
</sect2>
<sect2><heading>joy_emu_axis_set</heading>


<p>
 
 Update the axis status for each joystick.

 We must perform "axis mapping" if only the first joystick is enabled
 i.e. we are required to map the "excessive" axes (&gt;2) from the first
 joystick onto the second:

	a) 3rd axis of 1st joy --&gt; 2st axis of 2nd joy

	b) 4th axis of 1st joy --&gt; 1st axis of 2nd joy
	   (yes, these are reversed deliberately because it's what happens in DOS)

 
</p>
</sect2>
<sect2><heading>joy_emu_axis_conv</heading>


<p>
 
 Convert a Linux joystick axis reading to a DOS one by making use of
 the differences in the allowable range of axis values.

 NOTE: I don't know whether or not Linux returns exponential values
 for the joystick but (apparently) DOS programs expect the values to
 be exponential and so if this is to be fixed, it should probably be
 done in this function.

 
</p>
</sect2>
<sect2><heading>joy_linux_process_event</heading>


<p>
 
 Update global joystick status variables given a Linux joystick event.

 
</p>
</sect2>
<sect2><heading>joy_linux_read_events</heading>


<p>
 
 Process the event queue for _both_ linux joysticks using nonblocking
 reads with the new joystick API (joy_driver_new).

 This should be done before (well, actually, not before _every_
 single read -- see joy_latency_over()) the joystick status is returned
 to DOS as all Linux joystick events are queued until they are processed
 and we want to return a reasonably current state of the joystick
 -- not what it was a long time ago.  _Both_ joysticks are processed
 here because of axis/button mapping affecting the status of both emulated
 joysticks (what DOS sees).

 
</p>
</sect2>
<sect2><heading>joy_linux_read_status</heading>


<p>
 
 Read both the current position and current button status of the joystick
 from Linux (joy_driver_old).

 
</p>
</sect2>
<sect2><heading>joy_linux_read_buttons_(family)</heading>


<p>
 
 Eventually called from DOS to get the button status of the joysticks.
 The threaded version will simply get the status from global variables.
 The unthreaded versions will perform non-blocking reads.

 
</p>
</sect2>
<sect2><heading>joy_linux_read_axis_(family)</heading>


<p>
 
 Eventually called from DOS to get the axis status of the joysticks.
 The threaded version will simply get the values from global variables.
 The unthreaded versions will perform non-blocking reads.

</p><p>Arguments are:&nl;
<itemize>
<item>   invalid_val - value to return to signify a non-existent axis</item>
<item>   update - whether DOSEMU should update its internal axis values from Linux</item>
<item>            (for each read of the joystick position, set this flag _only_</item>
<item>             on the first of the 4 calls to this function unless you want</item>
<item>             the axis positions to be from different points in time :)</item>
</itemize>
</p>
</sect2>
<sect2><heading>joy_bios_read</heading>


<p>
 
 This is the int15 function 0x84 handler (i.e. BIOS joystick emulation),
 called from src/base/async/int.c.

 The real BIOS actually reads its values straight from the joystick port
 (0x201) but we don't bother because we can do it faster :)

 Because of this, it returns the joystick axis values with the same
 range as port 0x201 BUT the range for a real BIOS varies between
 computers as it is dependant on how it reads from the port
 (hopefully this won't cause any problems).

 
</p>
</sect2>
<sect2><heading>joy_port_inb</heading>


<p>
 
 This function emulates reads from the joystick port (0x201) -- this is
 the most common way of detecting and reading the joystick.

 The real implementation of this port sets a bit for each axis for a
 certain period of time, corresponding to analog measurements of the
 position of each axis (so "if you count the analog values in software,
 a faster machine yields different values from a slow machine &lsqb;unless
 you use a timer&rsqb;" - DOS 6: A Developer's Guide).

 In contrast, this implementation sets the bits high for a certain number
 of port reads, corresponding to the position of each axis (independent
 of time).  This means that, for most programs, the axis range will be
 that specified in dosemu.conf (which is rather convenient) and avoids
 the issue of super-fast computers causing DOS program axis counters to
 overflow (e.g. in a real system, if the program used an 8-bit variable
 for storing the position of an axis and the system was fast enough to
 read from the port more than 127 or 255 times, there would be trouble).

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in base/dev/misc/joystick.c</heading>

<p>
 We make a runtime decision based on the detected joystick API version
 and &num;ifdef USE_PTHREADS, on the way in which we obtain the joystick
 status from Linux (a "driver"):
 
 1. joy_driver_nojoy: simply tells DOS programs that you have no
                      joystick(s)

 2. joy_driver_old: uses old, non-blocking joystick API (&lt;1.0.0);
                    limited to 2 axes; supported because DOSEMU
                    supports old kernels

 3. joy_driver_new: uses new, non-blocking joystick API (&gt;=1.0.0);
                    a (little) slower than joy_driver_new_threaded

 4. joy_driver_new_threaded: uses new, BLOCKING joystick API (&gt;=1.0.0);
                             efficient but requires pthreads (which
                             is known to make DOSEMU unstable!)

 The same driver is used for both joysticks.

 
</p><p>-----</p>

<p> if the 2nd joystick is enabled, we ignore any button &gt;= 2 regardless
 of which joystick it is (if it's the 1st, the 2nd joystick would
 overwrite its buttons; if it's the 2nd, it would be out of range)
 
 
</p><p>-----</p>

<p> if the 2nd joystick is enabled, we ignore any axis &gt;= 2 regardless
 of which joystick it is (if it's the 1st, the 2nd joystick would
 overwrite its axes; if it's the 2nd, it would be out of range)
 
 
</p><p>-----</p>

<p> Apparently, the Carry Flag is cleared if int15 function 0x84 exists
 and it is set if it doesn't exist.
 
 But what does this mean?  Does the existence of such a BIOS function
 depend on the existence of a Game Card/SoundBlaster, or does it just
 mean that there is such an implemented BIOS function, regardless of
 whether or not you have a joystick?

 I have never seen a real BIOS set the Carry Flag on this call, even
 on a computer without a joystick -- so to mimick what happens in the
 real world, I just clear the Carry Flag regardless of whether the user
 has a joystick or not.  This could be incorrect behaviour so it may
 have to be changed in the future.

 
</p><p>-----</p>

<p> Here we set bits based on joystick axis counters.
 The code here is particularly tricky and if you try to change it, you
 will probably break it :)
 
 
</p><p>-----</p>

<p> Here we read the button status from Linux (programs can read the
 button status from the port, _without_ making a dummy write to the
 port first so the Linux read must be done _here_) and return it.
 
 
</p>
</sect1>

<sect1><heading>Items for Fixing in base/dev/misc/joystick.c</heading>

<p>
 does this code work for ports other than 0x201?

</p><p>-----</p>

<p> joy_reset() is called immediately after joy_init(), which is rather inconvenient (anyone heard of a port_unregister_handler()?) so we don't bother resetting at all but in the future this could cause problems

</p><p>-----</p>

<p> perhaps we should not have been called to start with?

</p>
</sect1>

<sect1><heading>Remarks in include/doshelpers.h</heading>

<p>
 The Helper Interrupt uses the following groups:
 
 0x00      - Check for DOSEMU
 0x01-0x11 - Initialisation functions &amp; Debugging
 0x12      - Set hogthreshold (aka garrot?)
 0x20      - MFS functions
 0x21-0x22 - EMS functions
 0x28      - Garrot Functions for use with the mouse
 0x29      - Serial functions
 0x30      - Whether to use the BOOTDISK predicate
 0x33      - Mouse Functions
 0x40      - CD-ROM functions
 0x50-0x5f - DOSEMU/Linux communications
      50 -- run unix command in ES:DX
      51,52?
      53 -- do system(ES:DX)
	54 -- get CPU speed
	55 -- get terminal type
 0x60-0x6f - reserved for plug-ins
 0x7a      - IPX functions
 0x8x   -- utility functions
	0x80 -- getcwd(ES:DX, size AX)
	0x81 -- chdir(ES:DX)
 0xdc      - helper for DosC kernel
 0xfe      - called from our MBR, emulate MBR-code.
 0xff      - Terminate DOSEMU
 
 There are (as yet) no guidelines on choosing areas for new functions.
 
</p>
</sect1>

</sect>

<sect><heading>The CPU_Intel group of Modules</heading>
<p>
These files all relate to Intel-x86 specific code.
</p>

<sect1><heading>Functions in emu-i386/cpu.c</heading>

<p>These are the functions defined in emu-i386/cpu.c.</p>

<sect2><heading>cpu_trap_0f</heading>


<p>
 
 process opcodes 0F xx xx trapped by GP_fault
 returns 1 if handled, 0 otherwise
 Main difference with previous version: bits in our pseudo-control
 regs can now be written. This should make CPU detection pgms happy.

 
</p>
</sect2>
<sect2><heading>cpu_setup</heading>


<p>
 
  Setup initial interrupts which can be revectored so that the kernel
 does not need to return to DOSEMU if such an interrupt occurs.

 
</p>
</sect2>
</sect1>

<sect1><heading>Functions in emu-i386/ports.c</heading>

<p>These are the functions defined in emu-i386/ports.c.</p>

<sect2><heading>port_inb(ioport_t port)</heading>


<p>
 
 Handles/simulates an inb() port IO read

 
</p>
</sect2>
<sect2><heading>port_outb(ioport_t port, Bit8u byte)</heading>


<p>
 
 Handles/simulates an outb() port IO write

 
</p>
</sect2>
<sect2><heading>port_inw(ioport_t port)</heading>


<p>
 
 Handles/simulates an inw() port IO read.  Usually this invokes
 port_inb() twice, but it may be necessary to do full word i/o for
 some video boards.

 
</p>
</sect2>
<sect2><heading>port_outw(ioport_t port, Bit16u word)</heading>


<p>
 
 Handles/simulates an outw() port IO write

 
</p>
</sect2>
<sect2><heading>port_ind(ioport_t port)</heading>


<p>
 
 Handles/simulates an ind()/outd() port IO read/write.

 
</p>
</sect2>
<sect2><heading>special_port_inb,special_port_outb</heading>


<p>
 
 I don't know what to do of this stuff... it was added incrementally to
 port.c and has mainly to do with video code. This is not the right
 place for it...
 Anyway, this implements some HGC stuff for X and the emuretrace
 port access for 0x3c0/0x3da

 
</p>
</sect2>
<sect2><heading>port_init()</heading>


<p>
 
 Resets all the port port_handler information.
 This must be called before parsing the config file -
 This must NOT be called again when warm booting!
 Can't use debug logging, it is called too early.

 
</p>
</sect2>
<sect2><heading>extra_port_init()</heading>


<p>
 
 Catch all the special cases previously defined in ports.c
 mainly video stuff that should be moved away from here
 This must be called at the end of initialization phase

 NOTE: the order in which these inits are done could be significant!
   I tried to keep it the same it was in ports.c but this code surely
   can still have bugs

 
</p>
</sect2>
<sect2><heading>port_register_handler</heading>


<p>
 
 Assigns a handle in the port table to a range of ports with or
 without a device, and registers the ports

 
</p>
</sect2>
<sect2><heading>set_ioperm</heading>


<p>
 
 wrapper for the ioperm() syscall, returns -1 if not successful.

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in emu-i386/ports.c</heading>

<p>
 The following port_{in|out}{bwd} functions are the main entry points to
 the port code. They look into the port_handle_table and call the
 appropriate code, usually the std_port_ functions, but each device is
 free to register its own functions which in turn will call std_port or
 directly access I/O (like video code does), or emulate it - AV
 
 
</p><p>-----</p>

<p> optimized versions for rep - basically we avoid changing privileges
 and iopl on and off lots of times. We are safe letting iopl=3 here
 since we don't exit from this code until finished.
 This code is shared between VM86 and DPMI.
 
 
</p><p>-----</p>

<p> This is the core of the new emuretrace algorithm:
 If a read of port 0x3da is performed we just set it
  as pending and set ioperm OFF for port 0x3c0
 When a write to port 0x3c0 is then trapped, we perform
  any pending read to 0x3da and reset the ioperm for
  0x3c0 in the default ON state.
 This way we avoid extra port accesses when the program
 is only looking for the sync bits, and we don't miss
 the case where the read to 0x3da is used to reset the
 index/data flipflop for port 0x3c0. Futher accesses to
 port 0x3c0 are handled at full speed.
 
 
</p><p>-----</p>

<p> find out whether the port address request is available;
 this way, try to deny uncoordinated access
 
 If it is not listed in /proc/ioports, register them 
 (we need some syscall to do so bo 960609)...
 (we have a module to do so AV 970813)
 if it is registered, we need the name of a device to open
 if we can't open it, we disallow access to that port
 
</p><p>-----</p>

<p> We need to check if our required port range is in use
 by some device. So we look into proc/ioports to check
 the addresses. Fine, but at this point we must supply
 a device name ourselves, and we can't check from here
 if it's the right one. The device is then open and left
 open until dosemu ends; for the rest, in the original
 code the device wasn't used, just locked, and only then
 port access was granted.
 
</p>
</sect1>

<sect1><heading>Items for Fixing in emu-i386/ports.c</heading>

<p>
 This stuff should be moved to video code!!

</p><p>-----</p>

<p> we should free the name but we are going to exit anyway

</p>
</sect1>

<sect1><heading>Functions in emu-i386/do_vm86.c</heading>

<p>These are the functions defined in emu-i386/do_vm86.c.</p>

<sect2><heading>vm86_GP_fault</heading>


<p>
 
 All from the kernel unhandled general protection faults from V86 mode
 are handled here. This are mainly port IO and the HLT instruction.

 
</p>
</sect2>
<sect2><heading>run_vm86</heading>


<p>
 
 Here is where DOSEMU runs VM86 mode with the vm86() call
 which also has the registers that it will be called with. It will stop
 vm86 mode for many reasons, like trying to execute an interrupt, doing
 port I/O to ports not opened for I/O, etc ...
 
 
</p>
</sect2>
<sect2><heading>loopstep_run_vm86</heading>


<p>
 
 Here we collect all stuff, that has to be executed within
 _one_ pass (step) of a loop containing run_vm86().
 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in emu-i386/do_vm86.c</heading>

<p>
 Here we handle all prefixes prior switching to the appropriate routines
 The exception CS:EIP will point to the first prefix that effects
 the faulting instruction, hence, 0x65 0x66 is same as 0x66 0x65.
 So we collect all prefixes and remember them.
 - Hans Lermen
 
</p>
</sect1>

<sect1><heading>Functions in emu-i386/cputime.c</heading>

<p>These are the functions defined in emu-i386/cputime.c.</p>

<sect2><heading>GETcpuTIME</heading>


<p>
 
 GETcpuTIME is a pointer to a function which returns the
 relative CPU time. Different methods of getting the time can
 then be implemented, currently there are two using
 gettimeofday() for 486 and TSC for pentium

 
</p>
</sect2>
<sect2><heading>GETusTIME(sc)</heading>


<p>
 
 GETusTIME returns the DOS time with 1-usec resolution
  using GETcpuTIME to get the implementation-dependent CPU time.
 The 'sc' parameter is unused.

 
</p>
</sect2>
<sect2><heading>GETtickTIME(sc)</heading>


<p>
 
 GETtickTIME returns the DOS time with 838ns resolution
  using GETcpuTIME to get the implementation-dependent CPU time.
 The 'sc' parameter is unused.

 
</p>
</sect2>
<sect2><heading>GETusSYSTIME()</heading>


<p>
 
 GETusSYSTIME returns the real CPU time with 1-usec resolution

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in emu-i386/cputime.c</heading>

<p>
 At the heart of the timing system in dosemu &gt;= 0.67.11 is the availability
 of the system time as a 64-bit &lsqb;type hitimer_t&rsqb; monoton value.
 (a 64-bit timer on a 200MHz CPU increments by 2^48 a day).
 
 Dosemu needs this time under two resolutions:
</p><p><verb>
   - a MICROSECOND resolution for general timing purposes
   - a TICK(838ns) resolution for PIT
</verb></p>
<p> On non-pentium machines, only the first one is available via the
 kernel call gettimeofday(). On the pentium and up, the situation is better
 since we have a cheap hi-res timer on-chip, and worse since this
 timer runs at a speed depending from the CPU clock (which we need
 to know/measure, and could be not 100&percnt; accurate esp. if the speed is
 a non-integer multiple of 33.3333).

 dosemu &gt;= 0.67.11 can use both timing methods (call them 486 and pentium),
 and switch between them in a dynamic way when configuring.

 At the first level (local to the file cputime.c) there are the
 RAW timer functions, addressed by RAWcpuTIME(). These get the
 actual absolute CPU time in usecs.

 At the second level, GETcpuTIME() returns the relative, zero-based
 system time. This is where the 486/pentium switch happens.

 The third level is the actual timer interface for dosemu and is
 made of two functions:
</p><p><verb>
  - GETusTIME(s)   gives the time in usecs
  - GETtickTIME(s) gives the time in ticks
</verb></p>
<p> The 's' parameter can be used to control secondary time functions
 like 'time stretching' (see the READMEs).
 The function GETusSYSTIME() never activates this stretching, and
 is used only by the realtime thread-based 1-sec timer in rtc.c.

 All timing are RELATIVE to a base. The use of a based time allows us
 to play more freely with time, e.g. stop and restart it during debugging,
 stretch it, make it go at different speeds between real-time and CPU
 emulation, etc. The base has been chosen to be zero, because it will
 avoid overflows in calculations, produce more readable and more easily
 comparable debug log files, and also because only int0x1a and BIOS
 timer require knowledge of the actual time, PIT and PIC are not sensitive.

 
</p>
</sect1>

<sect1><heading>Functions in emu-i386/simx86/sigsegv.c</heading>

<p>These are the functions defined in emu-i386/simx86/sigsegv.c.</p>

<sect2><heading>dosemu_fault(int, struct sigcontext_struct);</heading>


<p>
 
 All CPU exceptions (except 13=general_protection from V86 mode,
 which is directly scanned by the kernel) are handled here.

 
</p>
</sect2>
</sect1>

</sect>

<sect><heading>The Serial group of Modules</heading>
<p>
This is the code that works our serial emulation. This needs to be very fast
if we are to convince DOS that we have a very fast serial port.
</p>

<sect1><heading>Remarks in base/serial/ser_defs.h</heading>

<p>
 Extensions to serial debugging.
 
 SER_DEBUG_MAIN   (0 or 1)
   - extra debug output on the most critical information.

 SER_DEBUG_HEAVY   (0 or 1)
   - super-heavy extra debug output, including all ports reads and writes, 
      and every character received and transmitted!

 SER_DEBUG_INTERRUPT   (0 or 1)
   - additional debug output related to serial interrupt code,
      including flagging serial interrupts, or PIC-driven code.

 SER_DEBUG_FOSSIL_RW   (0 or 1)
   - heavy FOSSIL debug output, including all reads and writes.

 SER_DEBUG_FOSSIL_STATUS   (0 or 1)
   - super-heavy FOSSIL debug output, including all status checks.

 You must recompile dosemu everytime one of these constants are modified.
 Just type 'make' in the dosemu dir and it will recompile the changes only.
 
</p><p>-----</p>

<p> IMPORTANT INFO about com&lsqb;&rsqb; variable array structure used in serial.c
 
 Most of the serial variables are stored in the com&lsqb;&rsqb; array.
 The com&lsqb;&rsqb; array is a structure in itself.   Take a look at the
 'serial_t' struct declaration in the serial.h module for more info
 about this.  Only the most commonly referenced global variables
 are listed here:

   config.num_ser         Number of serial ports active.
   com&lsqb;x&rsqb;.base_port       The base port address of emulated serial port.
   com&lsqb;x&rsqb;.real_comport    The COM port number.
   com&lsqb;x&rsqb;.interrupt       The PIC interrupt level (based on IRQ number)
   com&lsqb;x&rsqb;.mouse           Flag  mouse (to enable extended features)
   com&lsqb;x&rsqb;.fd              File descriptor for port device 
   com&lsqb;x&rsqb;.dev&lsqb;&rsqb;           Filename of port port device
   com&lsqb;x&rsqb;.dev_locked      Flag whether device has been locked

 The arbritary example variable 'x' in com&lsqb;x&rsqb; can have a minimum value
 of 0 and a maximum value of (config.numser - 1).  There can be no gaps
 for the value 'x', even though gaps between actual COM ports are permitted.
 It is strongly noted that the 'x' does not equal the COM port number.
 This example code illustrates the fact, and how the com&lsqb;&rsqb; array works:

   for (i = 0; i &lt; config.numser; i++)
     s_printf("COM port number &percnt;d has a base address of &percnt;x", 
              com&lsqb;i&rsqb;.real_comport, com&lsqb;i&rsqb;.base_port);

 
</p>
</sect1>

<sect1><heading>Functions in base/serial/ser_init.c</heading>

<p>These are the functions defined in base/serial/ser_init.c.</p>

<sect2><heading>serial_init</heading>


<p>
 
 This is the master serial initialization function that is called
 upon startup of DOSEMU to initialize ALL the emulated UARTs for
 all configured serial ports.  The UART is initialized via the
 initialize_uart function, which opens the serial ports and defines
 variables for the specific UART.
 
 If the port is a mouse, the port is only initialized when i

 
</p>
</sect2>
</sect1>

<sect1><heading>Items for Fixing in base/serial/ser_init.c</heading>

<p>
 This needs more work before it is implemented into /etc/dosemu.conf as an 'rtscts' option.

</p>
</sect1>

<sect1><heading>Functions in base/serial/ser_ports.c</heading>

<p>These are the functions defined in base/serial/ser_ports.c.</p>

<sect2><heading>do_serial_in</heading>


<p>
 The following function returns a value from an I/O port.  The port
 is an I/O address such as 0x3F8 (the base port address of COM1). 
 There are 8 I/O addresses for each serial port which ranges from
 the base port (ie 0x3F8) to the base port plus seven (ie 0x3FF).
 &lsqb;num = abritary port number for serial line, address = I/O port address&rsqb;
 
</p>
</sect2>
<sect2><heading>do_serial_out </heading>


<p>
 The following function writes a value to an I/O port.  The port
 is an I/O address such as 0x3F8 (the base port address of COM1). 
 &lsqb;num = abritary port number for serial line, address = I/O port address,
 val = value to write to I/O port address&rsqb;
 
</p>
</sect2>
</sect1>

<sect1><heading>Items for Fixing in base/serial/ser_ports.c</heading>

<p>
 Should clearing UART cause THRE int if it's enabled? */

</p><p>-----</p>

<p> Fix the calculation assumption

</p><p>-----</p>

<p> Is this safe to put this here? */

</p><p>-----</p>

<p> Is this safe to put this here? */

</p>
</sect1>

<sect1><heading>Functions in base/serial/ser_irq.c</heading>

<p>These are the functions defined in base/serial/ser_irq.c.</p>

<sect2><heading>serial_int_engine</heading>


<p>
 
 This function is the serial interrupts scheduler.  Its purpose is to
 update interrupt status and/or invoke a requested serial interrupt.
 If interrupts are not enabled, the Interrupt Identification Register 
 is still updated and the function returns.  See pic_serial_run() below
 it is executed right at the instant the interrupt is actually invoked.
 
 Since it is not possible to run the interrupt on the spot, it triggers
 the interrupt via the pic_request() function (which is in pic.c)
 and sets a flag that an interrupt is going to be occur soon.

 Please read pic_serial_run() for more information about interrupts.
 &lsqb;num = port, int_requested = the requested serial interrupt&rsqb;
 
 
</p>
</sect2>
<sect2><heading>pic_serial_run </heading>


<p>
 
 This function is called by the priority iunterrupt controller when a
 serial interrupt occurs.  It executes the highest priority serial
 interrupt for that port. (Priority order is: RLSI, RDI, THRI, MSI)

 Because it is theoretically possible for things to change between the
 interrupt trigger and the actual interrupt, some checks must be 
 repeated.

 
</p>
</sect2>
<sect2><heading>serial_run </heading>


<p>
 
 This is the main housekeeping function, which should be called about
 20 to 100 times per second.  The more frequent, the better, up to 
 a certain point.   However, it should be self-compensating if it
 executes 10 times or even 1000 times per second.   Serial performance
 increases with frequency of execution of serial_run.

 Serial mouse performance becomes more smooth if the time between 
 calls to serial_run are smaller.

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in base/serial/ser_irq.c</heading>

<p>
 Linux code hackers: How do I detect a break signal without having
 to rely on Linux signals?  Can I peek a 'break state bit'?
 Also, how do I 'turn on' and 'turn off' the break state, via
 an ioctl() or tcsetattr(), rather than using POSIX tcsendbrk()?
 
</p>
</sect1>

<sect1><heading>Items for Fixing in base/serial/ser_irq.c</heading>

<p>
 how do we cancel a PIC interrupt, when we have come this far?

</p>
</sect1>

<sect1><heading>Functions in base/serial/int14.c</heading>

<p>These are the functions defined in base/serial/int14.c.</p>

<sect2><heading>int14</heading>


<p>
 The following function executes a BIOS interrupt 0x14 function.
 This code by Mark Rejhon replaced some very buggy, old int14 interface
 a while back.  These routines are not flawless since it does not wait
 for a character during receive, and this may confuse some programs.
 
</p>
</sect2>
</sect1>

<sect1><heading>New Ideas for base/serial/int14.c</heading>

<p>
 If any of you coders are ambitious, try thinking of the following:
 - Converting this into inline assembler and use direct port access 
 
</p></sect1>

<sect1><heading>Items for Fixing in base/serial/fossil.c</heading>

<p>
 This really should be write-with-wait. */

</p>
</sect1>

<sect1><heading>Items for Fixing in include/serial.h</heading>

<p>
 Why does a RX_BUFFER_SIZE of 256 cause slower performance than a size of 128?

</p>
</sect1>

</sect>

<sect><heading>The Mouse group of Modules</heading>
<p>
  All of the Mouse handling code is in the "mouse" subdirectory.

  There are only 2 main files, mouse.c and mouseint.c.
</p>

<sect1><heading>Functions in base/mouse/mouse.c</heading>

<p>These are the functions defined in base/mouse/mouse.c.</p>

<sect2><heading>mouse_init</heading>


<p>
 
  Initialize internal mouse.

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in base/mouse/mouse.c</heading>

<p>
 I have not properly tested this INT74 - JES 96/10/20 
 I have removed it.  INT74 is irq 12.  Which I suppose is the proper
 irq for a ps2 mouse.  It appears initial support was planned to
 support irq 12 and at Mouse_ROUTINE_OFF is a routine that
 acknowledges an irq.  That routine is probably what should be
 acknowledging irq12, and what int 0x74 should point to.  
 I have disabled int0x74 support for now. --EB 29 Oct 1997
 Got it working --BO 4 Nov 2004
 
</p><p>-----</p>

<p> Whoever wrote the dos mouse driver spec was brain dead...
 For some video modes the mouse driver appears to randomly
 pick a shift factor, possibly to keep at least a 640x200 resolution.
 
 The general programming documentation doesn't make this clear.
 And says that in text modes it is safe to divide the resolution by 
 8 to get the coordinates in characters.

 The only safe way to handle the mouse driver is to call function
 0x26 Get max x &amp; max y coordinates and scale whatever the driver 
 returns yourself.

 To handle programs written by programmers who weren't so cautious a
 doctrine of least suprise has been implemented.

 As much as possible do the same as a standard dos mouse driver in the
 original vga modes 0,1,2,3,4,5,6,7,13,14,15,16,17,18,19. 

 For other text modes allow the divide by 8 technique to work.
 For other graphics modes return x &amp; y in screen coordinates.
 Except when those modes are either 40x?? or 320x???
 and then handle the x resolution as in 40x25 and 320x200 modes.

 320x200 modes are slightly controversial as I have indications that
 not all mouse drivers do the same thing. So I have taken the
 simplest, and most common route, which is also long standing dosemu
 practice of always shifting the xaxis by 1.  When I researched this
 I could find no examples that did otherwise.
 

 -- Eric Biederman 19 August 1998

 This code has now been updated so it defaults as above but allows
 work arounds if necessary.  Because tweaking dosemu is easier
 than fixing applications without source.

 -- Eric Biederman 29 May 2000

 
</p>
</sect1>

</sect>

<sect><heading>The Bios group of Modules</heading>
<p>
  All of the Bios code is in the "bios" subdirectory.

  DOSEMU requires certain code to be coded in assembler and also code to
  be located in the F000 segment. This is where all such code should be
  put.
</p>

<sect1><heading>Functions in base/bios/hlt.c</heading>

<p>These are the functions defined in base/bios/hlt.c.</p>

<sect2><heading>hlt_init(void)</heading>


<p>
 
   Resets all the HLT handlers

 
</p>
</sect2>
<sect2><heading>hlt_handle()</heading>


<p>
 
 Handles a HLT instruction reached inside the dos emulator.

 
</p>
</sect2>
</sect1>

</sect>

<sect><heading>The PIC group of Modules</heading>
<p>
  All of the PIC handling code is in the "PIC" subdirectory.
</p>

<sect1><heading>Functions in base/dev/pic/pic.c</heading>

<p>These are the functions defined in base/dev/pic/pic.c.</p>

<sect2><heading>pic_print</heading>


<p>
 
 This is the pic debug message printer.  It writes out some basic 
 information, followed by an informative message.  The basic information
 consists of: 
       interrupt nesting counter change flag (+, -, or blank)
       interrupt nesting count (pic_icount)
       interrupt level change flag (+, -, or blank)
       current interrupt level
       interrupt in-service register
       interrupt mask register
       interrupt request register
       message part one
       decimal data value
       message part two

 If the message part 2 pointer is a null pointer, then only message
 part one (without the data value) is printed.

 The change flags are there to facilitate grepping for changes in 
 pic_ilevel and pic_icount
 
 To avoid line wrap, the first seven values are printed without labels.
 Instead, a header line is printed every 15 messages.

 
</p>
</sect2>
<sect2><heading>write_pic0,write_pic1</heading>


<p>
 
 write_pic_0() and write_pic1() implement dos writes to the pic ports.
 They are called by the code that emulates inb and outb instructions.
 Each function implements both ports for the pic:  pic0 is on ports
 0x20 and 0x21; pic1 is on ports 0xa0 and 0xa1.  These functions take
</p><p>Arguments are:&nl;
</p>
</sect2>
<sect2><heading>read_pic0,read_pic1</heading>


<p>
 
 read_pic0 and read_pic1 return the values for the interrupt mask register
 (port 1), or either the in service register or interrupt request register,
 as determined by the last OCW3 command (port 0).  These functions take
 a single parameter, which is a port number (0 or 1).  They are called by
 code that emulates the inb instruction.

 
</p>
</sect2>
<sect2><heading>pic_seti</heading>


<p>
 
 pic_seti is used to initialize an interrupt for dosemu.  It requires
 four parameters.  The first parameter is the interrupt level, which
 may select the NMI, any of the IRQs, or any of the 16 extra levels
 (16 - 31).  The second parameter is the dosemu function to be called
 when the interrupt is activated.  This function should call do_irq()
 if the DOS interrupt is really to be activated.  If there is no special
 dosemu code to call, the second parameter can specify do_irq(), but
 see that description for some special considerations. 
 The third parameter is a number of an interrupt to activate if there is
 no default interrupt for this ilevel.
 The fourth parameter is the dosemu function to be called from do_irq().
 Required by some internal dosemu drivers that needs some additional code
 before calling an actual handler. This function MUST provide a EOI at
 the end of a callback.

 
</p>
</sect2>
<sect2><heading>run_irqs</heading>


<p>
 
 run_irqs, which is initiated via the macro pic_run, is the "brains" of
 the pic.  It is called from the vm86() loop, checks for the highest
 priority interrupt requested, and executes it.  This function is
 written in assembly language in order to take advantage of atomic
 (indivisible) instructions, so that it should be safe for a two
 process model, even in a multiple CPU machine.  A c language
 version was started, but it became impossible, even with in-line 
 assembly macros, because such macros can only return a single result.
 If I find a way to do it in c, I will, but don't hold your breath.

 I found a way to write it in C --EB 15 Jan 97

 
</p>
</sect2>
<sect2><heading>do_irq</heading>


<p>
 
  do_irq() calls the correct do_int().
  It then executes a vm86 loop until an outb( end-of-interrupt) is found.
  For priority levels 0 and &gt;15 (not real IRQs), vm86 executes once, then 
  returns, since no outb20 will come.
  Returns: 0 = complete, 1 = interrupt not run because it directly
  calls our "bios"   See run_timer_tick() in timer.c for an example
  To assure notification when the irq completes, we push flags, ip, and cs
  here and fake cs:ip to PIC_&lsqb;SEG,OFF&rsqb;, where there is a hlt.  This makes 
  the irq generate a sigsegv, which calls pic_iret when it completes.
  pic_iret then pops the real cs:ip from the stack.
  This routine is RE-ENTRANT - it calls run_irqs,
  which may call an interrupt routine,
  which may call do_irq().  Be Careful!  !!!!!!!!!!!!!!!!!! 
  No single interrupt is ever re-entered.

 Callers:
 base/misc/ioctl.c
 base/keyboard/serv_8042.c
 base/keyboard/keyboard-server.c
 base/serial/ser_irq.c
 dosext/sound/sound.c
 dosext/net/net/pktnew.c

 
</p>
</sect2>
<sect2><heading>pic_resched</heading>


<p>
 
 pic_resched decrements a count of interrupts on the stack
 (set by do_irq()). If the count is then less or equal to some pre-defined
 value (normally 1, pic_icount_od), pic_resched moves all queued interrupts 
 to the interrupt request register.

 Normally it is called from pic_iret(), but it can also be called 
 directly if dosemu was fooled by the program and failed to catch iret.

 
</p>
</sect2>
<sect2><heading>pic_request</heading>


<p>
 
 pic_request triggers an interrupt.  There is presently no way to
 "un-trigger" an interrupt.  The interrupt will be initiated the
 next time pic_run is called, unless masked or superceded by a 
 higher priority interrupt.  pic_request takes one argument, an
 interrupt level, which specifies the interrupt to be triggered.
 If that interrupt is already active, the request will be queued 
 until all active interrupts have been completed.  The queue is
 only one request deep for each interrupt, so it is the responsibility
 of the interrupt code to retrigger itself if more interrupts are
 needed.

 
</p>
</sect2>
<sect2><heading>pic_iret</heading>


<p>
 
 pic_iret is used to sense that all active interrupts are really complete,
 so that interrupts queued by pic_request can be triggered.
 Interrupts end when they issue an outb 0x20 to the pic, however it is
 not yet safe at that time to retrigger interrupts, since the stack has
 not been restored to its initial state by an iret.  pic_iret is called
 whenever interrupts have been enabled by a popf, sti, or iret.  It 
 determines if an iret was the cause by comparing stack contents with
 cs and ip. If so, it calls pic_resched() and does the actual iret by
 pop'ing ip and cs from stack.
 It is possible for pic_iret to be fooled by dos code; for this reason 
 active interrupts are checked, any queued interrupts that are also 
 active will remain queued.
 Also, some programs fake an iret, so that it is possible for pic_iret 
 to fail.
 See pic_watch for the watchdog timer that catches and fixes this event.

 
</p>
</sect2>
<sect2><heading>pic_watch</heading>


<p>
 
 pic_watch is a watchdog timer for pending interrupts.  If pic_iret
 somehow fails to activate a pending interrupt request for 2 consecutive 
 timer ticks, pic_watch will activate them anyway.  pic_watch is called
 ONLY by timer_tick, the interval timer signal handler, so the two functions
 will probably be merged.

 
</p>
</sect2>
<sect2><heading>pic_pending</heading>


<p>
 This function returns a non-zero value if the designated interrupt has
 been requested and is not masked.  In these circumstances, it is important
 for a hardware emulation to return a status which does *not* reflect the
 event(s) which caused the request, until the interrupt actually gets 
 processed.  This, in turn, hides the interrupt latency of pic from the dos
 software.
 
 The single parameter ilevel is the interrupt level (see pic.h) of the
 interrupt of interest.

 If the requested interrupt level is currently active, the returned status
 will depend upon whether the interrupt code has re-requested itself.  If
 no re-request has occurred, a value of false (zero) will be returned.  
 
</p>
</sect2>
<sect2><heading>pic_activate</heading>


<p>
 
 pic_activate requests any interrupts whose scheduled time has arrived.
 anything after pic_dos_time and before pic_sys_time is activated.
 pic_dos_time is advanced to the earliest time scheduled.
 
</p>
</sect2>
<sect2><heading>pic_sched</heading>


<p>
 pic_sched schedules an interrupt for activation after a designated
 time interval.  The time measurement is in unis of 1193047/second,
 the same rate as the pit counters.  This is convenient for timer
 emulation, but can also be used for pacing other functions, such as
 serial emulation, incoming keystrokes, or video updates.  Some sample 
 intervals:
 
 rate/sec:	5	7.5	11	13.45	15	30	60
 interval:	238608	159072	108459	88702	79536	39768	19884

 rate/sec:	120	180	200	240	360	480	720
 interval:	9942	6628	5965	4971	3314	2485	1657

 rate/sec:	960	1440	1920	2880	3840	5760	11520
 interval:	1243	829	621	414	311	207	103	

 pic_sched expects two parameters: an interrupt level and an interval.
 To assure proper repeat scheduling, pic_sched should be called from
 within the interrupt handler for the same interrupt.  The maximum 
 interval is 15 minutes (0x3fffffff).
 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in base/dev/pic/pic.c</heading>

<p>
 pic_push,pic_pop
 
 Pic maintains two stacks of the current interrupt level. an internal one
 is maintained by run_irqs, and is valid whenever the emulator code for
 an interrupt is active.  These functions maintain an external stack,
 which is valid from the time the dos interrupt code is called until
 the code has issued all necessary EOIs.  Because pic will not necessarily 
 get control immediately after an EOI, another EOI (for another interrupt)
 could occur.  This external stack is kept strictly synchronized with
 the actions of the dos code to avoid any problems.  pic_push and pic_pop
 maintain the external stack.
 
</p>
</sect1>

</sect>

<sect><heading>The Sound group of Modules</heading>
<p>
The sound code provides emulation of the SB. The actual emulation provided
depends upon the support available from the kernel sound driver. Because
this is very OS dependant the driver code itself is kept in architecture
specifc files under src/arch/osname/dosext/sound/. Communication is via
a set of interface functions and the device independant structures.

</p>

<sect1><heading>Functions in dosext/sound/sound.c</heading>

<p>These are the functions defined in dosext/sound/sound.c.</p>

<sect2><heading>sb_io_read</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  port - The I/O port being read from.</item>
</itemize>
 This handles all of the reads for the SB emulation. The value read is
 returned. The value of 0xFF indicates an invalid read. (assumes the ports
 float high when not pulled low by the hardware.)

 
</p>
</sect2>
<sect2><heading>adlib_io_read</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  port - The I/O port being read from.</item>
</itemize>
 This handles all of the reads for the adlib (FM) emulation. The value read 
 is returned. The value of 0xFF indicates an invalid read. (assumes the ports
 float high when not pulled low by the hardware.)
 The FM emulation is not written yet. The current plan is to use the midi
 emulation where available as this is the most common use for the FM sound.

 
</p>
</sect2>
<sect2><heading>mpu401_io_read</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  port - The I/O port being read from.</item>
</itemize>
 The MPU-401 functionality is primarily provided by 'midid' - a standalone
 program. This makes most of the MPU-401 code simply a pass-through driver.

 
</p>
</sect2>
<sect2><heading>sb_io_write</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  port - The I/O port being written to.</item>
<item>  value - The value being output.</item>
</itemize>
 This handles the writes for the SB emulation. Very little of the processing
 is performed in this function as it basically consists of a very large
 switch() statement. The processing here is limited to trivial (1 line) items
 and distinguishing between the different actions and responses that the
 different revisions of the SB series give.

 
</p>
</sect2>
<sect2><heading>sb_dsp_write</heading>


<p>
 
</p><p>Arguments are:&nl;
<itemize>
<item>  value - The value being written to the DSP.</item>
</itemize>
 The SB DSP is a complete I/O system in itself controlled via a number of
 data bytes. The number of bytes depends upon the function. The function
 to be executed is determined by the first byte.
 If there is no existing command then the command is stored. This then used
 in the switch to identify the action to be taken. When the command has 
 supplied all of its arguments, or failed, then the command storage is 
 cleared. Each DSP function is responsible for clearing this itself.
 Again, this function relies on other functions to do the real work, and
 apart from storing details of the command and parameters is basically a
 large switch statement.

 
</p>
</sect2>
</sect1>

<sect1><heading>Remarks in dosext/sound/sound.c</heading>

<p>
 Write silence could probably be implemented by setting up a
 "DMA" transfer from /dev/null - AM
 
</p>
</sect1>

<sect1><heading>Items for Fixing in dosext/sound/sound.c</heading>

<p>
 The file header needs tidying up a _LOT_ ! */

</p><p>-----</p>

<p> Adlib status reads are unimplemented */

</p><p>-----</p>

<p> Advanced adlib reads are unimplemented */

</p><p>-----</p>

<p> CMS Writes are unimplemented.

</p><p>-----</p>

<p> DSP Status is unimplemented 

</p><p>-----</p>

<p> Adlib Waveform tests are unimplemented */

</p><p>-----</p>

<p> Advanced Adlib register writes are unimplemented */

</p><p>-----</p>

<p> Advanced Adlib data writes are unimplemented */

</p><p>-----</p>

<p> SB Midi is Unimplemented 

</p><p>-----</p>

<p> Sine Generation is unimplemented 

</p><p>-----</p>

<p> AUX Status is Unimplemented 

</p>
</sect1>

<sect1><heading>Remarks in base/dev/dma/dma.c</heading>

<p>
 **** WARNING ****
 This Code _HAS_ changed.
 
</p><p>-----</p>

<p> The Emulated DMA channels are provided by using files and writes.
 This means that they are easy to track.
 It might cause problems when attempting to interface to the REAL DMA
 controller. (Necessary to talk to hardware which uses DMA.)
 
 Note that DMA controller 2 uses word granular addressing and controller 1
 uses byte granular address ... this simplifies the code !

 
</p>
</sect1>

<sect1><heading>Items for Fixing in base/dev/dma/dma.c</heading>

<p>
 : Cascade Mode Reads are not supported 

</p><p>-----</p>

<p> : The Verify Mode is not supported 

</p><p>-----</p>

<p> : The Invalid Mode is not supported (!) 

</p>
</sect1>

</sect>

<sect><heading>The FileAccess group of Modules</heading>
<p>
This hold all kind of accessing files on a Unix filesysten from DOS.
</p>

<sect1><heading>Remarks in dosext/mfs/mfs.c</heading>

<p>
 The msdos_dir_ent structure has much more than 28 bytes. 
 Is this significant?
 
</p><p>-----</p>

<p> Added compares to device so that newer versions of Foxpro which test directories
 using xx\yy\device perform closer to whats DOS does.
 
 
</p>
</sect1>

<sect1><heading>Items for Fixing in dosext/mfs/mfs.c</heading>

<p>
 We probably should use llseek here for file &gt; 2 GBytes

</p><p>-----</p>

<p> returned size of struct dir_ent seems wrong at 28 bytes. */

</p>
</sect1>

</sect>

<sect><heading>And Finally ...</heading>

<p>The Following items are used to delimit the text used to create this file.
Whilst it is not necessary to know this, they are included because they may
be useful for searching, as they are (at least at the moment) reasonably 
unique.

DANG_BEGIN_MODULE / DANG_END_MODULE
	This will bracket a description of the file (normally at the
	start). Within this you may have the keyword 'Maintainer:' followed
	by a list (one line each) of maintainers for this packet. These
	will be turned into URLs.

DANG_BEGIN_FUNCTION / DANG_END_FUNCTION
	This brackets a description of functions (good this, isn't it!)
	Not every function needs to be described in this way - just the
	major ones. Within this you may have the keywords: `arguments:',
	`return:' and `description:', which will sort out the information
	following it to build proper lists.

DANG_BEGIN_STRUCT / DANG_END_STRUCT
	This brackets a description of structures and data definitions
	Not every structure needs to be described in this way - just the
	major ones. Within this you may have the keywords: `elements:',
	and `description:', which will sort out the information
	following it to build proper lists. Also, you may bracket the
	structur definition of real C-code, given you have one element
	per line. In this case comments (/*...*/) behind the element will
	be inserted properly into the formatted list while the C-code
	itself is still compilable.

DANG_BEGIN_REMARK / DANG_END_REMARK
	This brackets descriptions of obscure items, like data structures
	and architecture.

DANG_FIXTHIS
	This is a one line item, indicating a an area requiring a fix, or
	redesign.

DANG_BEGIN_NEWIDEA / DANG_END_NEWIDEA
	New Ideas Start Here! As Ideas are proposed, that get added with 
	their description, so that future generations can laugh at or
	code the ideas ..... These bracket the idea description.

DANG_BEGIN_CHANGELOG / DANG_END_CHANGELOG
	Changelogs - very useful for bug fixing, and avvailable for use
	with DPR (or that's the theory)

In addition there are some keywords, that are recognized within a bracket.

VERB ... /VERB
	This formats the enclosed text verbatim. This is valid within
	*_MODULE, *_REMARK, *_STRUCT, *_FUNCTION

REMARK ... /REMARK
	This is only valid within *_MODULE and also can contain VERB
	brackets. Its useful to when you want to have a global modul
        description

PROTO ... /PROTO
	This is only valid within *_FUNCTION and
	takes a C-function prototype as `verbatim' until either
	a `{' or a /PROTO is seen. After this all input is `skipped'
	until the next PROTO or a /SKIP.

SKIP ... /SKIP
	This is only valid within *_FUNCTION and skips formatting until
	either PROTO or /SKIP is seen.
</p>


</sect>


</article>

</linuxdoc>
